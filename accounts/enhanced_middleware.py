"""
Enhanced Authorization Middleware for Multi-Tenant System
Provides comprehensive security, audit logging, and company-scoped access control
"""
from django.utils.deprecation import MiddlewareMixin
from django.shortcuts import redirect
from django.contrib import messages
from django.core.exceptions import PermissionDenied
from django.http import HttpResponseForbidden, JsonResponse
from django.urls import reverse
from django.utils import timezone
from django.contrib.auth import get_user_model
import re
import logging

from .models import Company, UserCompany, AuditLog
from .authorization import AuthorizationService, Action

User = get_user_model()
logger = logging.getLogger(__name__)


class SecurityAuditMiddleware(MiddlewareMixin):
    \"\"\"\n    Middleware to log security events, failed access attempts, and user actions\n    \"\"\"\n    \n    def process_request(self, request):\n        # Store request context for audit logging\n        if hasattr(request, 'user') and request.user.is_authenticated:\n            # Store request metadata for audit logging\n            request.user._request_ip = self.get_client_ip(request)\n            request.user._request_user_agent = request.META.get('HTTP_USER_AGENT', '')[:500]\n            \n            # Log significant actions (POST/PUT/DELETE requests)\n            if request.method in ['POST', 'PUT', 'DELETE', 'PATCH']:\n                self.log_request_attempt(request)\n        \n        return None\n    \n    def process_exception(self, request, exception):\n        # Log security exceptions\n        if isinstance(exception, PermissionDenied) and hasattr(request, 'user'):\n            AuthorizationService.log_security_event(\n                request.user,\n                Action.READ,\n                'access_denied',\n                {\n                    'path': request.path,\n                    'method': request.method,\n                    'exception': str(exception)\n                }\n            )\n        \n        return None\n    \n    def get_client_ip(self, request):\n        \"\"\"Extract client IP address from request\"\"\"\n        x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')\n        if x_forwarded_for:\n            ip = x_forwarded_for.split(',')[0]\n        else:\n            ip = request.META.get('REMOTE_ADDR')\n        return ip\n    \n    def log_request_attempt(self, request):\n        \"\"\"Log significant request attempts\"\"\"\n        try:\n            # Determine resource type from URL\n            resource_type = self.extract_resource_type(request.path)\n            action = self.map_method_to_action(request.method)\n            \n            AuthorizationService.log_action(\n                request.user,\n                action,\n                resource_type,\n                {\n                    'path': request.path,\n                    'method': request.method,\n                    'has_files': bool(request.FILES),\n                    'content_type': request.content_type\n                },\n                getattr(request, 'company', None)\n            )\n        except Exception as e:\n            logger.error(f\"Failed to log request attempt: {e}\")\n    \n    def extract_resource_type(self, path):\n        \"\"\"Extract resource type from URL path\"\"\"\n        # Map URL patterns to resource types\n        patterns = {\n            r'/accounts/companies/': 'company',\n            r'/accounts/users/': 'user',\n            r'/invoicing/': 'invoice',\n            r'/expenses/': 'expense',\n            r'/inventory/': 'inventory',\n            r'/reports/': 'report',\n            r'/hr/': 'hr',\n            r'/sales/': 'sale',\n        }\n        \n        for pattern, resource in patterns.items():\n            if re.search(pattern, path):\n                return resource\n        \n        return 'unknown'\n    \n    def map_method_to_action(self, method):\n        \"\"\"Map HTTP method to audit action\"\"\"\n        method_mapping = {\n            'GET': Action.READ,\n            'POST': Action.CREATE,\n            'PUT': Action.UPDATE,\n            'PATCH': Action.UPDATE,\n            'DELETE': Action.DELETE\n        }\n        return method_mapping.get(method, Action.READ)\n\n\nclass CompanyAccessControlMiddleware(MiddlewareMixin):\n    \"\"\"\n    Enhanced middleware for company access control with better authorization\n    \"\"\"\n    \n    # URLs that don't require company context\n    EXEMPT_PATHS = [\n        '/admin/',\n        '/accounts/login/',\n        '/accounts/logout/',\n        '/accounts/register/',\n        '/accounts/profile/',\n        '/api/auth/',\n        '/static/',\n        '/media/',\n        '/',  # Homepage\n        '/about/',\n        '/contact/',\n    ]\n    \n    # Company-specific URL patterns that require validation\n    COMPANY_SCOPED_PATTERNS = [\n        r'/companies/(\\d+)/',\n        r'/api/companies/(\\d+)/',\n    ]\n    \n    def process_request(self, request):\n        # Skip for exempt paths\n        if self.is_exempt_path(request.path):\n            return None\n        \n        # Skip for unauthenticated users\n        if not request.user.is_authenticated:\n            return None\n        \n        # Handle company switching for super admins\n        if 'switch_company' in request.POST and AuthorizationService.is_super_admin(request.user):\n            return self.handle_company_switching(request)\n        \n        # Set active company context\n        company = self.get_active_company(request)\n        request.company = company\n        \n        # Validate company-scoped requests\n        company_id = self.extract_company_id_from_url(request.path)\n        if company_id:\n            try:\n                requested_company = AuthorizationService.validate_company_scoped_request(\n                    request.user, company_id\n                )\n                # Update request company to the one being accessed\n                request.company = requested_company\n            except PermissionDenied:\n                return self.handle_access_denied(request, company_id)\n        \n        return None\n    \n    def is_exempt_path(self, path):\n        \"\"\"Check if path is exempt from company access control\"\"\"\n        for exempt_path in self.EXEMPT_PATHS:\n            if path.startswith(exempt_path):\n                return True\n        return False\n    \n    def get_active_company(self, request):\n        \"\"\"Get the user's active company context\"\"\"\n        # Check session for active company (set by company switching)\n        company_id = request.session.get('active_company_id')\n        if company_id:\n            try:\n                company = Company.objects.get(id=company_id, is_active=True)\n                # Verify user still has access\n                if AuthorizationService.can_access_company(request.user, company):\n                    return company\n                else:\n                    # Remove invalid session\n                    del request.session['active_company_id']\n            except Company.DoesNotExist:\n                del request.session['active_company_id']\n        \n        # Fallback to user's primary company\n        if hasattr(request.user, 'company'):\n            return request.user.company\n        \n        # Get first available company for user\n        user_companies = AuthorizationService.get_user_companies(request.user)\n        return user_companies[0] if user_companies else None\n    \n    def extract_company_id_from_url(self, path):\n        \"\"\"Extract company ID from URL if present\"\"\"\n        for pattern in self.COMPANY_SCOPED_PATTERNS:\n            match = re.search(pattern, path)\n            if match:\n                return int(match.group(1))\n        return None\n    \n    def handle_company_switching(self, request):\n        \"\"\"Handle company switching for super admins\"\"\"\n        try:\n            company_id = request.POST.get('company_id')\n            if company_id:\n                company = Company.objects.get(id=company_id, is_active=True)\n                request.session['active_company_id'] = company.id\n                \n                # Log company switch\n                AuthorizationService.log_action(\n                    request.user,\n                    Action.SWITCH_COMPANY,\n                    'company',\n                    {\n                        'from_company_id': getattr(request.company, 'id', None),\n                        'to_company_id': company.id,\n                        'to_company_name': company.name\n                    }\n                )\n                \n                messages.success(request, f'Switched to {company.name}')\n        except Company.DoesNotExist:\n            messages.error(request, 'Invalid company selected')\n        \n        return None\n    \n    def handle_access_denied(self, request, company_id):\n        \"\"\"Handle access denied scenarios\"\"\"\n        if request.headers.get('Accept') == 'application/json':\n            return JsonResponse({\n                'error': 'Access denied',\n                'message': 'You do not have permission to access this company'\n            }, status=403)\n        else:\n            messages.error(request, 'You do not have permission to access that company')\n            return redirect('dashboard:home')\n\n\nclass QuerySetAuthorizationMiddleware(MiddlewareMixin):\n    \"\"\"\n    Middleware to automatically filter querysets based on user's company access\n    This ensures data isolation at the database level\n    \"\"\"\n    \n    def process_request(self, request):\n        # Add authorization context to request for views to use\n        if hasattr(request, 'user') and request.user.is_authenticated:\n            request.auth_service = AuthorizationService\n            \n            # Add helper methods for common authorization checks\n            request.can_access_company = lambda company: AuthorizationService.can_access_company(\n                request.user, company\n            )\n            request.has_permission = lambda permission, company=None: AuthorizationService.has_permission(\n                request.user, permission, company\n            )\n            request.enforce_permission = lambda permission, company=None: AuthorizationService.enforce_permission(\n                request.user, permission, company\n            )\n        \n        return None\n\n\nclass RateLimitMiddleware(MiddlewareMixin):\n    \"\"\"\n    Simple rate limiting middleware to prevent abuse\n    \"\"\"\n    \n    def __init__(self, get_response):\n        self.get_response = get_response\n        self.request_counts = {}\n        self.rate_limit = 100  # requests per minute\n        self.window = 60  # seconds\n    \n    def process_request(self, request):\n        if not request.user.is_authenticated:\n            return None\n        \n        # Get client identifier\n        client_id = self.get_client_identifier(request)\n        current_time = timezone.now().timestamp()\n        \n        # Clean old entries\n        self.cleanup_old_entries(current_time)\n        \n        # Check rate limit\n        if client_id in self.request_counts:\n            count, first_request = self.request_counts[client_id]\n            if current_time - first_request < self.window:\n                if count >= self.rate_limit:\n                    # Log rate limit violation\n                    AuthorizationService.log_security_event(\n                        request.user,\n                        Action.READ,\n                        'rate_limit_exceeded',\n                        {'client_id': client_id, 'count': count}\n                    )\n                    return HttpResponseForbidden('Rate limit exceeded')\n                self.request_counts[client_id] = (count + 1, first_request)\n            else:\n                self.request_counts[client_id] = (1, current_time)\n        else:\n            self.request_counts[client_id] = (1, current_time)\n        \n        return None\n    \n    def get_client_identifier(self, request):\n        \"\"\"Get unique client identifier\"\"\"\n        return f\"{request.user.id}_{request.META.get('REMOTE_ADDR', 'unknown')}\"\n    \n    def cleanup_old_entries(self, current_time):\n        \"\"\"Remove old entries from rate limit tracking\"\"\"\n        to_remove = []\n        for client_id, (count, first_request) in self.request_counts.items():\n            if current_time - first_request > self.window:\n                to_remove.append(client_id)\n        \n        for client_id in to_remove:\n            del self.request_counts[client_id]